<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Horror Crush</title>
    <style>
        :root {
            --size: 64px;
            --cols: 8;
            --gap: 8px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial;
            color: #eee;
            background: radial-gradient(circle at top, #1a1a1a 0%, #000 100%);
        }

        .container {
            width: 100%;
            max-width: calc(var(--cols) * var(--size) + (var(--cols)-1)*var(--gap) + 40px);
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px
        }

        h1 {
            font-size: 18px;
            margin: 0;
            color: #f33;
        }

        .stats {
            display: flex;
            gap: 12px;
            align-items: center
        }

        .panel {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 14px;
            border-radius: 12px;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 2px 6px rgba(255, 0, 0, 0.2)
        }

        .score {
            font-weight: 700;
            font-size: 16px;
            color: #fff
        }

        .btn {
            background: #f33;
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }

        .board {
            background: rgba(0, 0, 0, 0.8);
            padding: 18px;
            border-radius: 14px;
            display: grid;
            gap: var(--gap);
            grid-template-columns: repeat(var(--cols), var(--size));
            width: 100%;
            box-shadow: 0 4px 12px rgba(255, 0, 0, 0.3)
        }

        .candy {
            width: var(--size);
            height: var(--size);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
            transition: transform 120ms ease, opacity 200ms ease;
            background: #111;
        }

        .candy:active {
            transform: scale(0.94)
        }

        .candy.hidden {
            opacity: 0;
            transform: translateY(10px) scale(0.9);
        }

        .candy-label {
            font-size: 28px;
            animation: pulse 1.2s infinite;
        }

        /* Horror colors */
        .candy.red {
            background: linear-gradient(145deg, #660000, #cc0000);
        }

        .candy.blue {
            background: linear-gradient(145deg, #001133, #003366);
        }

        .candy.green {
            background: linear-gradient(145deg, #003300, #006633);
        }

        .candy.yellow {
            background: linear-gradient(145deg, #666600, #cccc00);
        }

        .candy.purple {
            background: linear-gradient(145deg, #330033, #660066);
        }

        .candy.orange {
            background: linear-gradient(145deg, #663300, #cc6600);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }
        }

        @media (max-width:520px) {
            :root {
                --size: 44px
            }

            h1 {
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Horror Crush</h1>
            <div class="stats">
                <div class="panel">
                    <div>Score</div>
                    <div class="score" id="score">0</div>
                </div>
                <button class="btn" id="restart">Restart</button>
            </div>
        </header>

        <main>
            <div class="board" id="board" aria-label="game board"></div>
            <div
                style="margin-top:16px; font-size:14px; background:rgba(0,0,0,0.6); padding:10px; border-radius:8px; line-height:1.4;">
                <strong>How to Play:</strong><br>
                • Click or drag one toy, then swap with an adjacent toy.<br>
                • Swipe on mobile to move toys.<br>
                • Match 3 or more of the same toys to clear them and score.<br>
                • New toys fall from the top, causing chain reactions.<br>
                • Use arrow keys after selecting a toy for fast play.<br>
                • Survive the horror and score big!
            </div>
        </main>
    </div>

    <script>
        (function () {
            const cols = 8, rows = 8;
            const boardEl = document.getElementById('board');
            const scoreEl = document.getElementById('score');
            const restartBtn = document.getElementById('restart');

            const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
            let squares = [];
            let firstSelected = null;
            let score = 0;
            let isAnimating = false;
            let dragSourceIndex = null;

            function randColor() { return colors[Math.floor(Math.random() * colors.length)]; }

            function createBoard() {
                boardEl.style.setProperty('--cols', cols);
                boardEl.innerHTML = '';
                squares = [];
                for (let i = 0; i < cols * rows; i++) {
                    const div = document.createElement('div');
                    div.className = 'candy';
                    div.dataset.index = i;
                    div.setAttribute('draggable', 'true');
                    div.addEventListener('click', onCandyClick);
                    div.addEventListener('dragstart', onDragStart);
                    div.addEventListener('dragover', onDragOver);
                    div.addEventListener('drop', onDrop);
                    addTouchEvents(div);
                    boardEl.appendChild(div);
                    squares.push(div);
                }
                fillBoardInitial();
            }

            function fillBoardInitial() {
                for (let i = 0; i < squares.length; i++) {
                    setCandy(squares[i], randColor());
                }
                while (true) {
                    const matches = findMatches();
                    if (matches.length === 0) break;
                    matches.forEach(idx => setCandy(squares[idx], randColor()));
                }
            }

            function setCandy(el, color) {
                el.className = 'candy ' + color;
                el.dataset.color = color;
                el.innerHTML = `<span class="candy-label">` + candyGlyph(color) + `</span>`;
                el.classList.remove('hidden');
            }

            function candyGlyph(color) {
                const map = {
                    red: '🤡',
                    blue: '👁️',
                    green: '🧟‍♂️',
                    yellow: '🕷️',
                    purple: '☠️',
                    orange: '🪓'
                };
                return map[color] || '🎃';
            }

            function onCandyClick(e) {
                if (isAnimating) return;
                const el = e.currentTarget;
                if (!firstSelected) {
                    firstSelected = el;
                    el.style.transform = 'translateY(-6px) scale(1.04)';
                    return;
                }
                if (el === firstSelected) { firstSelected.style.transform = ''; firstSelected = null; return; }
                const a = parseInt(firstSelected.dataset.index), b = parseInt(el.dataset.index);
                if (areAdjacent(a, b)) {
                    swapAndResolve(a, b);
                } else {
                    firstSelected.style.transform = '';
                    firstSelected = el;
                    el.style.transform = 'translateY(-6px) scale(1.04)';
                }
            }

            // Drag and drop handlers
            function onDragStart(e) { dragSourceIndex = parseInt(e.target.dataset.index); }
            function onDragOver(e) { e.preventDefault(); }
            function onDrop(e) {
                const targetIndex = parseInt(e.target.closest('.candy').dataset.index);
                if (areAdjacent(dragSourceIndex, targetIndex)) {
                    swapAndResolve(dragSourceIndex, targetIndex);
                }
                dragSourceIndex = null;
            }

            // Touch swipe support
            function addTouchEvents(el) {
                let startX, startY;
                el.addEventListener('touchstart', e => {
                    const t = e.touches[0];
                    startX = t.clientX; startY = t.clientY;
                });
                el.addEventListener('touchend', e => {
                    if (!startX || !startY) return;
                    const t = e.changedTouches[0];
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;
                    const absX = Math.abs(dx), absY = Math.abs(dy);
                    const idx = parseInt(el.dataset.index);
                    let target = null;
                    if (Math.max(absX, absY) > 20) {
                        if (absX > absY) {
                            target = idx + (dx > 0 ? 1 : -1);
                        } else {
                            target = idx + (dy > 0 ? cols : -cols);
                        }
                    }
                    if (target !== null && target >= 0 && target < cols * rows && areAdjacent(idx, target)) {
                        swapAndResolve(idx, target);
                    }
                    startX = startY = null;
                });
            }

            function areAdjacent(a, b) {
                const ax = a % cols, ay = Math.floor(a / cols);
                const bx = b % cols, by = Math.floor(b / cols);
                return (Math.abs(ax - bx) + Math.abs(ay - by)) === 1;
            }

            function swapAndResolve(i, j) {
                isAnimating = true;
                const a = squares[i], b = squares[j];
                const tempColor = a.dataset.color;
                setCandy(a, b.dataset.color);
                setCandy(b, tempColor);

                const matches = findMatches();
                if (matches.length === 0) {
                    setTimeout(() => {
                        const t = a.dataset.color;
                        setCandy(a, b.dataset.color);
                        setCandy(b, t);
                        cleanupSelection();
                        isAnimating = false;
                    }, 120);
                } else {
                    processMatchesCascade().then(() => { cleanupSelection(); isAnimating = false; });
                }
            }

            function cleanupSelection() {
                if (firstSelected) { firstSelected.style.transform = ''; }
                firstSelected = null;
            }

            function findMatches() {
                const matches = new Set();
                for (let r = 0; r < rows; r++) {
                    let runColor = null, runStart = 0, runLen = 0;
                    for (let c = 0; c < cols; c++) {
                        const idx = r * cols + c;
                        const color = squares[idx].dataset.color;
                        if (color === runColor) { runLen++; } else {
                            if (runLen >= 3) { for (let k = runStart; k < runStart + runLen; k++) matches.add(k); }
                            runColor = color; runStart = idx; runLen = 1;
                        }
                    }
                    if (runLen >= 3) { for (let k = runStart; k < runStart + runLen; k++) matches.add(k); }
                }
                for (let c = 0; c < cols; c++) {
                    let runColor = null, runStart = 0, runLen = 0;
                    for (let r = 0; r < rows; r++) {
                        const idx = r * cols + c;
                        const color = squares[idx].dataset.color;
                        if (color === runColor) { runLen++; } else {
                            if (runLen >= 3) { for (let k = runStart; k < runStart + runLen * cols; k += cols) matches.add(k); }
                            runColor = color; runStart = idx; runLen = 1;
                        }
                    }
                    if (runLen >= 3) { for (let k = runStart; k < runStart + runLen * cols; k += cols) matches.add(k); }
                }
                return Array.from(matches).sort((a, b) => a - b);
            }

            function processMatchesCascade() {
                return new Promise(async (resolve) => {
                    while (true) {
                        const matches = findMatches();
                        if (matches.length === 0) break;
                        score += matches.length * 10;
                        updateScore();

                        matches.forEach(i => {
                            const el = squares[i];
                            el.classList.add('hidden');
                            el.dataset.color = '';
                        });
                        await wait(180);
                        collapseColumns();
                        await wait(160);
                        fillEmptyWithNew();
                        await wait(160);
                    }
                    resolve();
                });
            }

            function collapseColumns() {
                for (let c = 0; c < cols; c++) {
                    let write = rows - 1;
                    for (let r = rows - 1; r >= 0; r--) {
                        const idx = r * cols + c;
                        const color = squares[idx].dataset.color;
                        if (color) {
                            if (write !== r) {
                                setCandy(squares[write * cols + c], color);
                                squares[write * cols + c].classList.remove('hidden');
                                squares[idx].dataset.color = '';
                                squares[idx].classList.add('hidden');
                            }
                            write--;
                        }
                    }
                    for (let r = write; r >= 0; r--) {
                        const idx = r * cols + c;
                        squares[idx].dataset.color = '';
                        squares[idx].classList.add('hidden');
                    }
                }
            }

            function fillEmptyWithNew() {
                for (let i = 0; i < squares.length; i++) {
                    if (!squares[i].dataset.color) {
                        setCandy(squares[i], randColor());
                    }
                }
            }

            function wait(ms) { return new Promise(res => setTimeout(res, ms)); }
            function updateScore() { scoreEl.textContent = score; }

            restartBtn.addEventListener('click', () => { score = 0; updateScore(); createBoard(); });
            createBoard();

            window.addEventListener('keydown', (e) => {
                if (!firstSelected || isAnimating) return;
                const idx = parseInt(firstSelected.dataset.index);
                let target = null;
                switch (e.key) {
                    case 'ArrowLeft': target = idx - 1; break;
                    case 'ArrowRight': target = idx + 1; break;
                    case 'ArrowUp': target = idx - cols; break;
                    case 'ArrowDown': target = idx + cols; break;
                }
                if (target !== null && target >= 0 && target < cols * rows && areAdjacent(idx, target)) {
                    swapAndResolve(idx, target);
                }
            });

        })();
    </script>
</body>

</html>